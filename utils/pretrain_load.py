# coding=utf-8from __future__ import absolute_import, print_functionfrom torch.backends import cudnnimport modelsimport torchcudnn.benchmark = Truedef load_parameter(model):    vgg = models.create('vgg', pretrained=True)    vgg_dict = vgg.state_dict()    vgg_name = [k for k, _ in vgg_dict.items() if k in vgg_dict]    model_dict = model.state_dict()    model_name = [k for k, _ in model_dict.items() if k in model_dict]    Num_overlap_layers = 78    for i in range(Num_overlap_layers):        model_dict[model_name[i]] = vgg_dict[vgg_name[i]]    model.load_state_dict(model_dict)    return modeldef set_bn_eval(m):    classname = m.__class__.__name__    if classname.find('BatchNorm') != -1:        m.eval()def save_model(model, filename):    state = model.state_dict()    for key in state:        state[key] = state[key].clone().cpu()    torch.save(state, filename)# print(model.state_dict()[model_name[0]][0][0])# print(vgg.state_dict()[vgg_name[0]][0][0])## model = models.create(args.net)## model_dict = model.state_dict()# model_name = [k for k, _ in model_dict.items() if k in model_dict]# model_weights = [v for k, v in model_dict.items() if k in model_dict]### print(model_name)### n = 0# for z in model_weights:#     n += 1#     print(z.shape)## z = np.array([torch.abs(torch.sum(k * l)).cpu().numpy() for l in V])# # model_dict.update(pretrained_dict)# # model_dict['features.34.weight'].shape# model.features = torch.nn.Sequential(#     model.features,#     torch.nn.MaxPool2d(7),#     # torch.nn.BatchNorm2d(512),#     torch.nn.Dropout(p=0.01)# )mode